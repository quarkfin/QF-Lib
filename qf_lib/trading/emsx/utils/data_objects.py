#     Copyright 2016-present CERN â€“ European Organization for Nuclear Research
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
from datetime import datetime

from sqlalchemy import MetaData, UniqueConstraint, Column, Sequence, Integer, VARCHAR, Numeric, TIMESTAMP
from sqlalchemy.ext.declarative import declarative_base

EMSXBase = declarative_base(metadata=MetaData())


class EMSXTransaction(EMSXBase):
    """ Represents a single transaction. """

    __tablename__ = "emsx_transactions"
    __table_args__ = (
        UniqueConstraint('ext_order_id', 'fill_id', name='unique_fill_order_ids'),
    )
    id: int = Column(Integer, Sequence("transaction_id", start=1), primary_key=True)
    """primary key of the table, sequence"""
    int_order_id: int = Column(Integer)  # TODO rename to reference_order_id -> None in case of subscription
    """the internal ID of the Order, associated with the transaction entry"""
    ext_order_id: int = Column(Integer)  # TODO rename it to emsx_sequence
    """identification number of the order, which was generated by the external system"""
    fill_id: int = Column(Integer)
    """id of the fill (transaction), assigned by the broker"""
    price: float = Column(Numeric(30, 10))
    """price at which the transaction was filled"""
    time_value: datetime = Column(TIMESTAMP, nullable=False)
    """time, when the transaction was filled"""
    quantity: int = Column(Numeric(30), nullable=False)
    """filled quantity (the number is always positive, the side parameter determines if it is a buy or a sell)"""
    side: str = Column(VARCHAR(4))
    """determines the side of the transaction (either buy or sell)"""
    commission: float = Column(Numeric(30, 10))
    """value of the commission"""

    def __repr__(self):
        return f"Transaction:\n\t" \
               f"INTERNAL ORDER ID: {self.int_order_id},\n\t" \
               f"EXTERNAL ORDER ID: {self.ext_order_id},\n\t" \
               f"FILL ID: {self.fill_id},\n\t" \
               f"PRICE: {self.price},\n\t" \
               f"DATETIME: {self.time_value}\n\t" \
               f"QUANTITY: {self.quantity},\n\t" \
               f"SIDE: {self.side},\n\t" \
               f"COMMISSION: {self.commission}\n\t"

    def __eq__(self, other):
        return (self.id, self.int_order_id, self.ext_order_id, self.fill_id, self.price, self.time_value, self.quantity,
                self.side, self.commission) == (
               other.id, other.int_order_id, other.ext_order_id, other.fill_id, other.price,
               other.time_value, other.quantity, other.side, other.commission)

    def __hash__(self):
        return hash((self.id, self.int_order_id, self.ext_order_id, self.fill_id, self.price, self.time_value,
                     self.quantity, self.side, self.commission))


class EMSXOrder(EMSXBase):
    """
    Table which contains ONLY the sent orders (routes in the EMSX terminology).
    """
    __tablename__ = "orders"

    id: int = Column(Integer, Sequence("order_id", start=1), primary_key=True)
    """primary key, integer sequence"""
    int_order_id: int = Column(Integer, nullable=True)
    """internal identification number of the order, used to ensure the uniqueness of order ids for each of the vendors.
    In case of the EMSX platform the int_order_id is passed as the EMSX_ORD_REF_ID (16 char limit) in the messages."""
    ext_order_id: int = Column(Integer, nullable=True)
    """identification number of the order, which was generated by the external system / third party (EMSX_SEQUENCE) 
    and identifies the order in that system uniquely."""
    side: str = Column(VARCHAR(4))
    """string describe the side of the order: 'SELL' or 'BUY'"""
    tif: str = Column(VARCHAR(5))
    """time in force ("DAY", "OPG" or "GTC")"""
    quantity: int = Column(Integer, nullable=False)
    """quantity of the order"""
    status: str = Column(VARCHAR(20))
    """status of the order (e.g. for Interactive Brokers Filled, Pre-Submitted etc)"""
    order_type: str = Column(VARCHAR(3))
    """type of the order: 'MKT', 'STP'"""
    time_value: datetime = Column(TIMESTAMP)
    """time, when the order was submitted / status was updated"""
    strategy = Column(VARCHAR(200))
    """name of the corresponding strategy"""
    exchange: str = Column(VARCHAR(50))
    """name of exchange"""
    broker: str = Column(VARCHAR(50))
    """name of the broker / platform, which was used to send the order"""
    currency: str = Column(VARCHAR(3))
    """string representing the currency of the commission (e.g. USD, PLN)"""

    security_code = Column(VARCHAR(200), nullable=False)  # TODO rename to bbg ticker
    """Contract / ticker, which was used in the order (the field is broker-specific, e.g. EMSX may use the Bloomberg
    Tickers as security codes, while Interactive Brokers may use the information from the IBContract)"""

    def __repr__(self):
        return f"StrategyOrder:\n\t" \
               f"INTERNAL ORDER ID: {self.int_order_id},\n\t" \
               f"EXTERNAL ORDER ID: {self.ext_order_id},\n\t" \
               f"SIDE: {self.side},\n\t" \
               f"TIF: {self.tif},\n\t" \
               f"QUANTITY: {self.quantity},\n\t" \
               f"STATUS: {self.status},\n\t" \
               f"ORDER TYPE: {self.order_type},\n\t" \
               f"DATETIME: {self.time_value}\n\t" \
               f"STRATEGY: {self.strategy},\n\t" \
               f"EXCHANGE: {self.exchange},\n\t" \
               f"BROKER: {self.broker},\n\t" \
               f"CURRENCY: {self.currency},\n\t" \
               f"SECURITY: {self.security_code},\n\t"

    def __eq__(self, other):
        return (self.id, self.int_order_id, self.ext_order_id, self.side, self.tif,
                self.quantity, self.status, self.order_type, self.time_value, self.strategy,
                self.exchange, self.broker, self.currency, self.security_code) == (
                   other.id, other.int_order_id, other.ext_order_id, other.side, other.tif,
                   other.quantity, other.status, other.order_type, other.time_value, other.strategy,
                   other.exchange, other.broker, other.currency, other.security_code)
