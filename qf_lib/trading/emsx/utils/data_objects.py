#     Copyright 2016-present CERN â€“ European Organization for Nuclear Research
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
from datetime import datetime

from sqlalchemy import MetaData, UniqueConstraint, Column, Sequence, Integer, VARCHAR, Numeric, TIMESTAMP
from sqlalchemy.ext.declarative import declarative_base

from qf_lib.backtesting.portfolio.transaction import Transaction
from qf_lib.common.tickers.tickers import BloombergTicker

EMSXBase = declarative_base(metadata=MetaData())


class EMSXTransaction(EMSXBase):
    """ Represents a single transaction. """

    __tablename__ = "emsx_transactions"
    __table_args__ = (
        UniqueConstraint('emsx_seq', 'fill_id', name='unique_fill_order_ids'),
    )

    id: int = Column(Integer, Sequence("emsx_transaction_id", start=1), primary_key=True)
    """primary key of the table, sequence"""
    order_ref_id: int = Column(Integer)
    """the internal ID of the Order, associated with the transaction entry"""
    emsx_seq: int = Column(Integer)
    """identification number of the order, which was generated by the external system"""
    fill_id: int = Column(Integer)
    """id of the fill (transaction), assigned by the broker"""
    price: float = Column(Numeric(30, 10))
    """price at which the transaction was filled"""
    time_value: datetime = Column(TIMESTAMP, nullable=False)
    """time, when the transaction was filled"""
    quantity: int = Column(Numeric(30), nullable=False)
    """filled quantity (the number is always positive, the side parameter determines if it is a buy or a sell)"""
    side: str = Column(VARCHAR(4))
    """determines the side of the transaction (either buy or sell)"""
    commission: float = Column(Numeric(30, 10))
    """value of the commission"""
    bbg_ticker = Column(VARCHAR(200), nullable=False)
    """string representing the bloomberg ticker, which was used in the order"""
    currency: str = Column(VARCHAR(3))
    """string representing the currency of the commission (e.g. USD, PLN)"""

    def __repr__(self):
        return f"EMSX Transaction:\n\t" \
               f"REFERENCE ID: {self.order_ref_id},\n\t" \
               f"EMSX SEQUENCE: {self.emsx_seq},\n\t" \
               f"FILL ID: {self.fill_id},\n\t" \
               f"PRICE: {self.price},\n\t" \
               f"DATETIME: {self.time_value}\n\t" \
               f"QUANTITY: {self.quantity},\n\t" \
               f"SIDE: {self.side},\n\t" \
               f"COMMISSION: {self.commission}\n\t" \
               f"SECURITY: {self.bbg_ticker},\n\t" \
               f"CURRENCY: {self.currency},\n\t"

    def __eq__(self, other):
        return (self.id, self.order_ref_id, self.emsx_seq, self.fill_id, self.price, self.time_value, self.quantity,
                self.side, self.commission) == (
                   other.id, other.order_ref_id, other.emsx_seq, other.fill_id, other.price,
                   other.time_value, other.quantity, other.side, other.commission)

    def __hash__(self):
        return hash((self.id, self.order_ref_id, self.emsx_seq, self.fill_id, self.price, self.time_value,
                     self.quantity, self.side, self.commission))

    @property
    def transaction(self):
        return Transaction(self.time_value, BloombergTicker(self.bbg_ticker), self.quantity, self.price,
                           self.commission, self.fill_id, currency=self.currency)


class EMSXOrder(EMSXBase):
    """ Table which contains only the sent orders (routes in the EMSX terminology). """
    __tablename__ = "emsx_orders"

    id: int = Column(Integer, Sequence("emsx_order_id", start=1), primary_key=True)
    """primary key, integer sequence"""
    order_ref_id: int = Column(Integer, nullable=True)
    """internal identification number of the order, used to ensure the uniqueness of order ids for each of the vendors.
    In case of the EMSX platform the order_ref_id is passed as the EMSX_ORD_REF_ID (16 char limit) in the messages."""
    emsx_seq: int = Column(Integer, nullable=True)
    """identification number of the order, which was generated by the external system / third party (EMSX_SEQUENCE)
    and identifies the order in that system uniquely."""
    side: str = Column(VARCHAR(4))
    """string describe the side of the order: 'SELL' or 'BUY'"""
    tif: str = Column(VARCHAR(5))
    """time in force ("DAY", "OPG" or "GTC")"""
    quantity: int = Column(Integer, nullable=False)
    """quantity of the order"""
    status: str = Column(VARCHAR(20))
    """status of the order (e.g. for Interactive Brokers Filled, Pre-Submitted etc)"""
    order_type: str = Column(VARCHAR(3))
    """type of the order: 'MKT', 'STP'"""
    time_value: datetime = Column(TIMESTAMP)
    """time, when the order was submitted / status was updated"""
    strategy = Column(VARCHAR(200))
    """name of the corresponding strategy"""
    exchange: str = Column(VARCHAR(50))
    """name of exchange"""
    broker: str = Column(VARCHAR(50))
    """name of the broker / platform, which was used to send the order"""
    currency: str = Column(VARCHAR(3))
    """string representing the currency of the commission (e.g. USD, PLN)"""
    bbg_ticker = Column(VARCHAR(200), nullable=False)
    """string representing the bloomberg ticker, which was used in the order"""

    def __repr__(self):
        return f"StrategyOrder:\n\t" \
               f"ORDER REFERENCE ID: {self.order_ref_id},\n\t" \
               f"EMSX SEQUENCE: {self.emsx_seq},\n\t" \
               f"SIDE: {self.side},\n\t" \
               f"TIF: {self.tif},\n\t" \
               f"QUANTITY: {self.quantity},\n\t" \
               f"STATUS: {self.status},\n\t" \
               f"ORDER TYPE: {self.order_type},\n\t" \
               f"DATETIME: {self.time_value}\n\t" \
               f"STRATEGY: {self.strategy},\n\t" \
               f"EXCHANGE: {self.exchange},\n\t" \
               f"BROKER: {self.broker},\n\t" \
               f"CURRENCY: {self.currency},\n\t" \
               f"SECURITY: {self.bbg_ticker},\n\t"

    def __eq__(self, other):
        return (self.id, self.order_ref_id, self.emsx_seq, self.side, self.tif,
                self.quantity, self.status, self.order_type, self.time_value, self.strategy,
                self.exchange, self.broker, self.currency, self.bbg_ticker) == (
                   other.id, other.order_ref_id, other.emsx_seq, other.side, other.tif,
                   other.quantity, other.status, other.order_type, other.time_value, other.strategy,
                   other.exchange, other.broker, other.currency, other.bbg_ticker)
